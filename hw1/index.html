<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Homework 1 Write-Up</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 0;
            padding: 0;
        }

        h1 {
            margin-top: 20px;
            margin-bottom: 10px;
        }

        p {
            margin-top: 0;
            margin-bottom: 20px;
        }
    </style>
</head>
<body>

<h1>Task 1</h1>
<p>
    To rasterize my triangles, I looped through all points of the screen and checked if each point was within the triangle by treating the edges as lines. The algorithm works well because it efficiently determines if a point is inside the triangle.
</p>
<p>
    Instead of recalculating l0, l1, and l2 for every point, I calculated them at the beginning and updated them at each point. This optimization makes the algorithm roughly twice as fast as the unoptimized version.
</p>

<h1>Task 2</h1>
<p>
    My supersampling algorithm increases the size of the sample buffer to width * height * sample_rate. It also adjusts dxi and dyi by dividing them by sqrt(sample_rate). When reading the sample buffer to the frame buffer, I examine a box of pixels of size sqrt(sample_rate) x sqrt(sample_rate). Supersampling is useful because it reduces jaggies and moire patterns, resulting in crisper and less compressed renders. It also anti-aliases triangles, providing smoother color transitions.
</p>

<h1>Task 3</h1>
<p>
    For Task 3, I envisioned the cube man performing a one-handed handstand on a well-maintained green lawn, with a beautiful cloudless sky in the background.
</p>

<h1>Task 4</h1>
<p>
    Barycentric coordinates represent the normalized distance to each vertex of the triangle. The sums of barycentric coordinates always equal 1, and the closer a point is to a vertex, the larger its influence. This results in a continuous color gradient inside the triangle relative to each vertex.
</p>

<h1>Task 5</h1>
<p>
    Pixel sampling is a technique for rendering image textures onto a canvas. I implemented it in two ways: nearest and bilinear. Nearest sampling selects the closest texel to the coordinates normalized based on the triangle’s new coordinates, while bilinear sampling takes the four closest pixels to the transformed pixel and normalizes them based on distance. Bilinear sampling produces slightly smoother results compared to nearest sampling, especially noticeable with very small texture images.
</p>

<h1>Task 6</h1>
<p>
    Level sampling involves sampling different resolution images to aid in antialiasing and blurring in 3D. I implemented it by using the derivatives of the transform to decide which mipmap level to sample from, and then used pixel sampling to get the pixel color. Trilinear interpolation was added to improve blending between level transitions by interpolating between them.
</p>
<p>
    Pixel sampling doesn’t use additional memory but can slow down with bilinear interpolation as it needs to retrieve four different values from the texture. Level sampling requires more memory as all the different levels need to be stored in memory. It helps significantly with antialiasing in 3D, as different distances can act more independently. Supersampling provides excellent antialiasing results but requires exponentially more memory and computational resources.
</p>

</body>
</html>
